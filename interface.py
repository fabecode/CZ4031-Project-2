from flask import Flask, render_template, redirect, request
from preprocessing import Database
import networkx as nx
import matplotlib.pyplot as plt
import random
import os
import time
from annotation import *

##################################### Flask App #####################################
class FlaskApp:
    def __init__(self):
        self.app = Flask(__name__)
        self.db = Database()

        @self.app.route('/', methods=["GET"])
        def requestQuery():
            #Currently hardcoded till linked to db
            db_schemas = ['TBC-H', 'Others']
            return render_template('home.html', db_schemas = db_schemas)

        @self.app.route("/queryplan", methods=["POST", "GET"])
        def queryPlan():
            if request.method == "POST":
                query = request.form["queryText"]
                print("Query:", query)
                if self.db.checkValidQuery(query):
                    qep = self.db.query(query)
                    self.db.generateQueryPlan(qep["Plan"])
                    render_args = {
                        "query": query,
                        "annotations": self.db.queryPlanList,
                        "total_cost": qep["Plan"]["Total Cost"],
                        "total_plan_rows": qep["Plan"]["Plan Rows"]
                    }
                    # restore to default
                    self.db.queryPlanList = []
                    self.scanDict = {}
                    self.joinDict = {}
                    return render_template("queryplan.html", **render_args)
            return redirect('/')
           
    def run(self):
        self.app.run()

##################################### Node & Graph #####################################

class Node:
    def __init__(self, node_type, cost):
        """Initialises a node with its type and total cost

        Args:
            node_type (str):  Node type of itself
            cost (str): Total cost until this node
        """
        self.node_type = node_type
        self.total_cost = cost

    def __str__(self):
        """Overrides the __str__ method to represent the class objects as a string.

        Returns:
            str: String representation of Node.
        """
        return f"{self.node_type}\ncost: {self.total_cost}"


class QueryPlan:
    def __init__(self, query):
        """Initialises the root node with the root query plan.
        Constructs the graph and calculate attributes of the QEP:
        1. Total cost
        2. Plan rows
        3. Number of sequential scan nodes
        4. Number of index scan nodes
        4. Explanation of the query plan

        Args:
            query (dict): Query plan that is generated by PostgreSQL
        """
        self.graph = nx.DiGraph()
        self.root = Node(query["Node Type"],query["Total Cost"])
        self.construct_graph(self.root,query)
        self.num_seq_scan_nodes = self.calculate_num_nodes("Seq Scan")
        self.num_index_scan_nodes = self.calculate_num_nodes("Index Scan")

    def construct_graph(self, root,query):
        """Constructs the graph recursively by forming an edge between each node
        and each of its child nodes.

        Args:
            root (Node): The parent node.
        """
        self.graph.add_node(root)
        if "Plans" not in query:
            return
        for child in query["Plans"]:
            child_node = Node(child["Node Type"],child["Total Cost"])
            self.graph.add_edge(root, child_node)
            self.construct_graph(child_node,child)

    def calculate_num_nodes(self, node_type: str) -> int:
        """Calculate the total number of nodes in the query with a specified node type.

        Args:
            node_type (str): Type of node (e.g. Seq Scan, Index Scan)

        Returns:
            int: Number of nodes with the specified node type.
        """
        num_nodes = 0
        for node in self.graph.nodes:
            if node.node_type == node_type:
                num_nodes += 1
        return num_nodes

    def calculate_plan_rows(self) -> int:
        """Calculate the total plan rows of the QEP via the summation of individual plan rows of each node.

        Returns:
            int: Total plan rows of QEP
        """
        plan_rows = 0
        for node in self.graph.nodes:
            plan_rows += node.plan_rows
        return plan_rows

    def save_graph_file(self) -> str:
        """Renders the graph and save the figure as an .png file
        in the 'static' folder.
        The frontend then renders the image on the UI to visualise the QEP.

        Returns:
            str: File name of graph
        """
        graph_name = f"qep_{str(time.time())}.png"
        file_name = os.path.join(os.getcwd(), "static", graph_name)
        plot_formatter_position = get_tree_node_pos(self.graph, self.root)
        node_labels = {x: str(x) for x in self.graph.nodes}
        nx.draw(
            self.graph,
            plot_formatter_position,
            with_labels=True,
            labels=node_labels,
            font_size=6,
            node_size=2000,
            node_color="#E2FAB5",
            node_shape="s",
            alpha=1,
        )
        plt.savefig(file_name)
        plt.clf()
        return graph_name


def get_tree_node_pos(G, root=None, width=1.0, height=1, vert_gap=0.1, vert_loc=0, xcenter=0.5):
    """From Joel's answer at https://stackoverflow.com/a/29597209/2966723.
    Licensed under Creative Commons Attribution-Share Alike

    Recursive program to define the positions. The recursion happens in _hierarchy_pos, which is called by get_tree_node_pos.
    The main role of hierarchy_pos is to do a bit of testing to make sure the graph is appropriate before entering the recursion.

    If the graph is a tree this will return the positions to plot this in a hierarchical layout.

    Args:
        G (DiGraph): The graph (must be a tree).
        root (Node, optional): The root node of the current branch.
        - If the tree is directed and this is not given, the root will be found and used.
        - If the tree is directed and this is given, the positions will be just for the descendants of this node.
        - If the tree is undirected and not given, a random choice will be used.
        Defaults to None.
        width (float, optional): Horizontal space allocated for this branch. Defaults to 1.0.
        height (int, optional): Vertical space allocated for this branch. Defaults to 1.
        vert_gap (float, optional):  Gap between levels of hierarchy. Defaults to 0.1.
        vert_loc (int, optional): Vertical location of root. Defaults to 0.
        xcenter (float, optional): Horizontal location of root. Defaults to 0.5.

    Raises:
        TypeError: Graph is not a tree.

    Returns:
        dict: [description]
    """

    if not nx.is_tree(G):
        raise TypeError("cannot use hierarchy_pos on a graph that is not a tree")

    if root is None:
        if isinstance(G, nx.DiGraph):
            root = next(iter(nx.topological_sort(G)))  # allows back compatibility with nx version 1.11
        else:
            root = random.choice(list(G.nodes))

    path_dict = dict(nx.all_pairs_shortest_path(G))
    max_height = 0
    for value in path_dict.values():
        max_height = max(max_height, len(value))
    vert_gap = height / max_height

    def _hierarchy_pos(
        G,
        root,
        width,
        vert_gap,
        vert_loc,
        xcenter,
        pos=None,
        parent=None,
        min_dx=0.05,
    ):
        """Refer to get_tree_node_pos docstring for most arguments.

        Args:
            parent (Node, optional): Parent of the current branch. (Only affects it if non-directed). Defaults to None.

        Returns:
            [dict]: a dict that maps each node to its corresponding location if they have been assigned.
        """

        if pos is None:
            pos = {root: (xcenter, vert_loc)}
        else:
            pos[root] = (xcenter, vert_loc)
        children = list(G.neighbors(root))
        if not isinstance(G, nx.DiGraph) and parent is not None:
            children.remove(parent)
        if len(children) != 0:
            dx = max(min_dx, width / len(children))
            nextx = xcenter - width / 2 - max(min_dx, dx / 2)
            for child in children:
                nextx += dx
                pos = _hierarchy_pos(
                    G,
                    child,
                    width=dx,
                    vert_gap=vert_gap,
                    vert_loc=vert_loc - vert_gap,
                    xcenter=nextx,
                    pos=pos,
                    parent=root,
                )
        return pos

    return _hierarchy_pos(G, root, width, vert_gap, vert_loc, xcenter)
# from output import query
# if __name__=='__main__':
#     qp = QueryPlan(query)
#     qp.save_graph_file()